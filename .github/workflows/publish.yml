name: Build and Release macOS App

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-macos:
    runs-on: macos-latest

    steps:
      - name: Clean runner environment
        run: |
          set -euo pipefail
          echo "ðŸ§¹ Cleaning runner environment..."

          # Remove any existing non-default keychains
          security list-keychains -d user | grep -o '[^"]*\.keychain' | while read keychain; do
            if [[ "$keychain" != "login.keychain" && "$keychain" != "System.keychain" ]]; then
              echo "Removing keychain: $keychain"
              security delete-keychain "$keychain" 2>/dev/null || true
            fi
          done

          # Clean Flutter cache
          rm -rf ~/.pub-cache 2>/dev/null || true
          rm -rf ~/flutter/.pub-cache 2>/dev/null || true

          # Clean any leftover certificate / artifact files
          rm -f *.p12 *.zip *.dmg 2>/dev/null || true

          echo "âœ… Runner environment cleaned"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version-file: pubspec.yaml
          channel: "stable"

      - name: Import Code Signing Certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }} # base64(.p12)
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12

          security create-keychain -p "" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "" build.keychain

          # Ensure build.keychain is searched by codesign
          security list-keychains -d user -s build.keychain login.keychain
          security default-keychain -s build.keychain

          # Import P12 and explicitly allow codesign to use the key
          security import certificate.p12 \
            -k build.keychain \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -T /usr/bin/codesign -T /usr/bin/security

          # Partition list (modern requirement)
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain

          rm -f certificate.p12

          echo "Identities in build.keychain (codesigning):"
          security find-identity -p codesigning -v build.keychain || true

      - name: Extract Team ID from imported cert
        run: |
          set -euo pipefail
          # Try via certificate subject (handles 'OU = ...' and 'OU=...')
          TEAM_ID=$(security find-certificate -a -c "Developer ID Application" -p build.keychain \
            | openssl x509 -noout -subject -nameopt RFC2253 \
            | sed -n 's/.*OU *= *\([^,]*\).*/\1/p' \
            | head -1)

          # Fallback: parse from identity line "Developer ID Application: â€¦ (TEAMID)"
          if [[ -z "${TEAM_ID:-}" ]]; then
            IDENTITY_LINE=$(security find-identity -p codesigning -v build.keychain \
              | awk -F\" '/Developer ID Application/ {print $2; exit}')
            TEAM_ID=$(awk -F'[()]' '{print $2}' <<< "$IDENTITY_LINE" || true)
          fi

          if [[ -z "${TEAM_ID:-}" ]]; then
            echo "âŒ Could not derive Team ID from cert or identity"
            echo "Diagnostics:"
            security find-identity -p codesigning -v build.keychain || true
            security find-certificate -a -c "Developer ID Application" -Z build.keychain || true
            exit 1
          fi

          echo "TEAM_ID_FROM_CERT=$TEAM_ID" >> "$GITHUB_ENV"
          echo "âœ… Team ID from cert: $TEAM_ID"

      - name: Prepare Flutter ephemeral files
        run: |
          set -euo pipefail
          flutter --version
          flutter precache --macos
          flutter pub get
          mkdir -p macos/Flutter/ephemeral
          : > macos/Flutter/ephemeral/FlutterInputs.xcfilelist
          : > macos/Flutter/ephemeral/FlutterOutputs.xcfilelist

      - name: Resolve Swift Package Manager dependencies
        run: |
          set -euo pipefail
          echo "ðŸ”§ Resolving Swift Package Manager dependencies..."

          # CocoaPods (ensure workspace is up to date)
          (cd macos && pod install)

          # Resolve SPM packages
          xcodebuild -resolvePackageDependencies \
            -workspace macos/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release

          echo "âœ… SPM dependencies resolved"

      - name: Build macOS app (unsigned via xcodebuild)
        run: |
          set -euo pipefail
          echo "ðŸ—ï¸ Building macOS app without signing..."

          # Point Xcode's Run Script to the Flutter SDK & app path
          FLUTTER_ROOT="$(dirname "$(dirname "$(which flutter)")")"
          export FLUTTER_ROOT
          export FLUTTER_APPLICATION_PATH="$GITHUB_WORKSPACE"

          xcodebuild \
            -workspace macos/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath macos/build \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            DEVELOPMENT_TEAM="" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            FLUTTER_ROOT="$FLUTTER_ROOT" \
            FLUTTER_APPLICATION_PATH="$FLUTTER_APPLICATION_PATH"

          APP_PATH=$(echo macos/build/Build/Products/Release/*.app | head -1)
          if [[ -z "${APP_PATH:-}" || ! -d "$APP_PATH" ]]; then
            echo "âŒ .app not found"; exit 1
          fi
          echo "APP_PATH=$APP_PATH" >> "$GITHUB_ENV"
          echo "Built app: $APP_PATH"

      - name: Verify framework embedding
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          echo "ðŸ” Checking for required frameworks..."

          # First, list all frameworks found
          echo "ðŸ“‹ All frameworks found in $APP_PATH/Contents/Frameworks:"
          if [[ -d "$APP_PATH/Contents/Frameworks" ]]; then
            ls -la "$APP_PATH/Contents/Frameworks/" | grep -E "\.framework|\.dylib" || echo "No frameworks or dylibs found"
          else
            echo "Frameworks directory not found"
          fi
          echo ""

          # Then check for required frameworks
          REQUIRED_FRAMEWORKS=("FlutterMacOS.framework" "appkit_ui_element_colors.framework")
          for framework in "${REQUIRED_FRAMEWORKS[@]}"; do
            if [[ -d "$APP_PATH/Contents/Frameworks/$framework" ]]; then
              echo "âœ… Found: $framework"
            else
              echo "âŒ Missing: $framework"
              exit 1
            fi
          done

      - name: Code sign the app
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          TEAM_ID="${{ env.TEAM_ID_FROM_CERT }}"

          # Pick the Developer ID identity for the same team as the cert we imported
          IDENTITY=$(security find-identity -p codesigning -v build.keychain \
            | awk -v team="($TEAM_ID)" -F\" '/Developer ID Application/ && $0 ~ team {print $2; exit}')
          if [[ -z "$IDENTITY" ]]; then
            echo "âŒ No 'Developer ID Application' identity for team $TEAM_ID in build.keychain."
            security find-identity -p codesigning -v build.keychain || true
            exit 1
          fi
          echo "Using identity: $IDENTITY"

          # Resolve entitlements with proper team ID substitution
          ENTITLEMENTS=""
          if [[ -f "macos/Runner/Release.entitlements" ]]; then
            echo "ðŸ”§ Resolving entitlements for Team ID: $TEAM_ID"
            RESOLVED_ENTITLEMENTS="$(pwd)/resolved_entitlements.plist"
            ./scripts/resolve_entitlements.sh "macos/Runner/Release.entitlements" "$TEAM_ID" "$RESOLVED_ENTITLEMENTS"
            ENTITLEMENTS="$RESOLVED_ENTITLEMENTS"
            echo "ðŸ“‹ Using resolved entitlements: $ENTITLEMENTS"
          else
            echo "âš ï¸  No Release.entitlements found, signing without entitlements"
          fi

          echo "Signing frameworks..."
          if [[ -d "$APP_PATH/Contents/Frameworks" ]]; then
            for framework in "$APP_PATH/Contents/Frameworks"/*.framework; do
              [[ -d "$framework" ]] || continue
              echo "â†’ $framework"
              codesign --keychain build.keychain --force --options runtime --timestamp \
                ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} \
                --sign "$IDENTITY" "$framework"
            done
          fi

          echo "Signing main binary..."
          MAIN_BIN=$(find "$APP_PATH/Contents/MacOS" -type f -perm -111 | head -1)
          if [[ -z "${MAIN_BIN:-}" ]]; then echo "âŒ Main binary not found"; exit 1; fi
          codesign --keychain build.keychain --force --options runtime --timestamp \
            ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} \
            --sign "$IDENTITY" "$MAIN_BIN"

          echo "Signing app bundle..."
          codesign --keychain build.keychain --deep --force --verify --verbose=2 --options runtime --timestamp \
            ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} \
            --sign "$IDENTITY" "$APP_PATH"

          echo "Verifying signature..."
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Check entitlements on main binary (debug guard)
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          MAIN_BIN=$(find "$APP_PATH/Contents/MacOS" -type f -perm -111 | head -1)
          echo "ðŸ” Checking entitlements on main binary: $MAIN_BIN"
          echo ""
          echo "ðŸ“‹ Actual entitlements applied:"
          codesign -d --entitlements :- "$MAIN_BIN" 2>/dev/null || echo "No entitlements found"
          echo ""
          # Hard fail if get-task-allow is present/true (not allowed for Dev ID)
          if codesign -d --entitlements :- "$MAIN_BIN" 2>/dev/null | grep -q "get-task-allow"; then
            echo "âŒ com.apple.security.get-task-allow present. Remove it for Release/Dev ID."
            exit 1
          else
            echo "âœ… No debug entitlements found (get-task-allow not present)"
          fi

      - name: Create zip for notarization
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          APP_NAME=$(basename "$APP_PATH" .app)
          ZIP_PATH="$GITHUB_WORKSPACE/${APP_NAME}.zip"

          # Create a zip suitable for notarization (preserves resource forks, etc.)
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" "$ZIP_PATH"

          echo "ZIP_PATH=$ZIP_PATH" >> "$GITHUB_ENV"
          echo "ðŸ“¦ Zip created: $ZIP_PATH"
          ls -lh "$ZIP_PATH"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          ZIP_PATH="${{ env.ZIP_PATH }}"
          TEAM_ID="${{ env.TEAM_ID_FROM_CERT }}"

          # Ensure jq is available
          command -v jq >/dev/null 2>&1 || brew install jq

          echo "Submitting with Apple ID: $APPLE_ID"
          echo "Team ID (from cert OU): $TEAM_ID"

          xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait \
            --output-format json > notary-submit.json

          echo "Notary submit response:"
          cat notary-submit.json

          STATUS=$(jq -r '.status // empty' notary-submit.json)
          SUBMISSION_ID=$(jq -r '.id // empty' notary-submit.json)

          if [ -z "$STATUS" ] || [ -z "$SUBMISSION_ID" ]; then
            echo "âŒ Could not parse status/id from notary-submit.json"
            exit 1
          fi

          if [ "$STATUS" != "Accepted" ]; then
            echo "Notarization status: $STATUS (id: $SUBMISSION_ID). Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --team-id "$TEAM_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --output-format json > notary-log.json || true
            # Pretty-print if possible
            jq '.' notary-log.json || cat notary-log.json || true
            exit 1
          fi

          echo "Stapling ticket..."
          xcrun stapler staple "$APP_PATH"

          echo "Gatekeeper assessment..."
          spctl --verbose=4 --assess --type execute "$APP_PATH"
          echo "Notarized and approved"

      - name: Create DMG (optional - for direct distribution)
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          APP_NAME=$(basename "$APP_PATH" .app)
          hdiutil create -volname "$APP_NAME" -srcfolder "$APP_PATH" -ov -format UDZO "$APP_NAME.dmg"
          echo "âœ… DMG created: $APP_NAME.dmg"

      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: |
            *.dmg
            *.zip
          draft: false
          prerelease: false
          generate_release_notes: true

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get zip filename for cask update
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          ZIP_FILENAME=$(basename "${{ env.ZIP_PATH }}")
          echo "ZIP_FILENAME=$ZIP_FILENAME" >> "$GITHUB_ENV"

      - name: Trigger cask update workflow
        if: startsWith(github.ref, 'refs/tags/')
        continue-on-error: true
        uses: peter-evans/repository-dispatch@v3
        with:
          token: ${{ secrets.CASK_DISPATCH_PAT }} # PAT in app repo
          repository: RikuVan/homebrew-formulae
          event-type: update-cask
          client-payload: |-
            {
              "version": "${{ github.ref_name }}",
              "download_url": "https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/${{ env.ZIP_FILENAME }}"
            }

      - name: Cleanup keychain
        if: always()
        run: |
          security default-keychain -s login.keychain || true
          security delete-keychain build.keychain || true
