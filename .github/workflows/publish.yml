name: Build and Release macOS App

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

jobs:
  build-macos:
    runs-on: macos-latest

    steps:
      - name: Clean runner environment
        run: |
          set -euo pipefail
          echo "ðŸ§¹ Cleaning runner environment..."

          # Remove any existing non-default keychains
          security list-keychains -d user | grep -o '[^"]*\.keychain' | while read keychain; do
            if [[ "$keychain" != "login.keychain" && "$keychain" != "System.keychain" ]]; then
              echo "Removing keychain: $keychain"
              security delete-keychain "$keychain" 2>/dev/null || true
            fi
          done

          # Clean Flutter cache
          rm -rf ~/.pub-cache 2>/dev/null || true
          rm -rf ~/flutter/.pub-cache 2>/dev/null || true

          # Clean any leftover certificate / artifact files
          rm -f *.p12 *.zip *.dmg 2>/dev/null || true

          echo "âœ… Runner environment cleaned"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version-file: pubspec.yaml
          channel: "stable"

      - name: Import Code Signing Certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }} # base64(.p12)
          MACOS_CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12

          security create-keychain -p "" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security unlock-keychain -p "" build.keychain

          # Ensure build.keychain is searched by codesign
          security list-keychains -d user -s build.keychain login.keychain
          security default-keychain -s build.keychain

          # Import P12 and explicitly allow codesign to use the key
          security import certificate.p12 \
            -k build.keychain \
            -P "$MACOS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -T /usr/bin/codesign -T /usr/bin/security

          # Partition list (modern requirement)
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain

          rm -f certificate.p12

          echo "Identities in build.keychain (codesigning):"
          security find-identity -p codesigning -v build.keychain || true

      - name: Extract Team ID from imported cert
        run: |
          set -euo pipefail
          # Try via certificate subject (handles 'OU = ...' and 'OU=...')
          TEAM_ID=$(security find-certificate -a -c "Developer ID Application" -p build.keychain \
            | openssl x509 -noout -subject -nameopt RFC2253 \
            | sed -n 's/.*OU *= *\([^,]*\).*/\1/p' \
            | head -1)

          # Fallback: parse from identity line "Developer ID Application: â€¦ (TEAMID)"
          if [[ -z "${TEAM_ID:-}" ]]; then
            IDENTITY_LINE=$(security find-identity -p codesigning -v build.keychain \
              | awk -F\" '/Developer ID Application/ {print $2; exit}')
            TEAM_ID=$(awk -F'[()]' '{print $2}' <<< "$IDENTITY_LINE" || true)
          fi

          if [[ -z "${TEAM_ID:-}" ]]; then
            echo "âŒ Could not derive Team ID from cert or identity"
            echo "Diagnostics:"
            security find-identity -p codesigning -v build.keychain || true
            security find-certificate -a -c "Developer ID Application" -Z build.keychain || true
            exit 1
          fi

          echo "TEAM_ID_FROM_CERT=$TEAM_ID" >> "$GITHUB_ENV"
          echo "âœ… Team ID from cert: $TEAM_ID"

      - name: Prepare Flutter ephemeral files
        run: |
          set -euo pipefail
          flutter --version
          flutter precache --macos
          flutter pub get
          mkdir -p macos/Flutter/ephemeral
          : > macos/Flutter/ephemeral/FlutterInputs.xcfilelist
          : > macos/Flutter/ephemeral/FlutterOutputs.xcfilelist

      - name: Build macOS app (unsigned via xcodebuild)
        run: |
          set -euo pipefail
          echo "ðŸ—ï¸ Building macOS app without signing..."

          # CocoaPods (ensure workspace is up to date)
          (cd macos && pod install)

          # Point Xcode's Run Script to the Flutter SDK & app path
          FLUTTER_ROOT="$(dirname "$(dirname "$(which flutter)")")"
          export FLUTTER_ROOT
          export FLUTTER_APPLICATION_PATH="$GITHUB_WORKSPACE"

          xcodebuild \
            -workspace macos/Runner.xcworkspace \
            -scheme Runner \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath macos/build \
            CODE_SIGNING_ALLOWED=NO \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGN_IDENTITY="" \
            DEVELOPMENT_TEAM="" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            FLUTTER_ROOT="$FLUTTER_ROOT" \
            FLUTTER_APPLICATION_PATH="$FLUTTER_APPLICATION_PATH"

          APP_PATH=$(echo macos/build/Build/Products/Release/*.app | head -1)
          if [[ -z "${APP_PATH:-}" || ! -d "$APP_PATH" ]]; then
            echo "âŒ .app not found"; exit 1
          fi
          echo "APP_PATH=$APP_PATH" >> "$GITHUB_ENV"
          echo "Built app: $APP_PATH"

      - name: Code sign the app (Developer ID Application)
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          TEAM_ID="${{ env.TEAM_ID_FROM_CERT }}"

          # Select identity that matches the extracted Team ID
          IDENTITY=$(security find-identity -p codesigning -v build.keychain \
            | awk -v team="($TEAM_ID)" -F\" '/Developer ID Application/ && $0 ~ team {print $2; exit}')
          if [[ -z "$IDENTITY" ]]; then
            echo "âŒ No 'Developer ID Application' identity for team $TEAM_ID in build.keychain."
            security find-identity -p codesigning -v build.keychain || true
            exit 1
          fi
          echo "Using identity: $IDENTITY"

          ENTITLEMENTS="macos/Runner/Runner.entitlements"
          [[ -f "$ENTITLEMENTS" ]] || ENTITLEMENTS=""

          # Sign nested frameworks
          if [[ -d "$APP_PATH/Contents/Frameworks" ]]; then
            find "$APP_PATH/Contents/Frameworks" -type d -name "*.framework" -print0 \
              | while IFS= read -r -d '' f; do
                  codesign --keychain build.keychain --force --options runtime --timestamp \
                    ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} --sign "$IDENTITY" "$f"
                done
            find "$APP_PATH/Contents/Frameworks" -type f \( -name "*.dylib" -o -name "*.so" \) -print0 \
              | while IFS= read -r -d '' f; do
                  codesign --keychain build.keychain --force --options runtime --timestamp \
                    ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} --sign "$IDENTITY" "$f"
                done
          fi

          # Sign all executables (helpers, main binary, etc.)
          find "$APP_PATH/Contents" \( -path "*/MacOS/*" -o -path "*/Helpers/*" \) -type f -perm -111 -print0 \
            | while IFS= read -r -d '' f; do
                codesign --keychain build.keychain --force --options runtime --timestamp \
                  ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} --sign "$IDENTITY" "$f"
              done

          # Bundle last
          codesign --keychain build.keychain --deep --force --verify --verbose=2 --options runtime --timestamp \
            ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} --sign "$IDENTITY" "$APP_PATH"

          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Create zip for notarization
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          APP_NAME=$(basename "$APP_PATH" .app)
          (cd "$(dirname "$APP_PATH")" && zip -r "$GITHUB_WORKSPACE/$APP_NAME.zip" "$APP_NAME.app")
          echo "ZIP_PATH=$GITHUB_WORKSPACE/$APP_NAME.zip" >> "$GITHUB_ENV"
          echo "ðŸ“¦ Zip created: $GITHUB_WORKSPACE/$APP_NAME.zip"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          ZIP_PATH="${{ env.ZIP_PATH }}"
          TEAM_ID="${{ env.TEAM_ID_FROM_CERT }}"

          echo "Submitting with Apple ID: $APPLE_ID and Team ID: $TEAM_ID"
          xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --wait

          echo "Stapling ticket..."
          xcrun stapler staple "$APP_PATH"

          echo "Gatekeeper assessment..."
          spctl --verbose=4 --assess --type execute "$APP_PATH"
          echo "âœ… Notarized and approved"

      - name: Create DMG (optional - for direct distribution)
        run: |
          set -euo pipefail
          APP_PATH="${{ env.APP_PATH }}"
          APP_NAME=$(basename "$APP_PATH" .app)
          hdiutil create -volname "$APP_NAME" -srcfolder "$APP_PATH" -ov -format UDZO "$APP_NAME.dmg"
          echo "âœ… DMG created: $APP_NAME.dmg"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: |
            *.dmg
            *.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
